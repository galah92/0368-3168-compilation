import java.io.PrintWriter;
import java_cup.runtime.*;
import AST.*;

parser code 
{:
    public Lexer lexer;
    public PrintWriter writer;

    public Parser(Lexer lexer, PrintWriter writer)
    {
        this.lexer = lexer;
        this.writer = writer;
    }
    public void report_error(String message, Object info)
    {
        writer.println("ParserError(" + lexer.getLine() + ")");
        writer.close();
        System.exit(0);
    }
:}


/* CUSTOMIZE CUP PARSER */
scan with
{:
    return lexer.next_token();
:};


/* TERMINALS */
terminal LPAREN;
terminal RPAREN;
terminal LBRACK;
terminal RBRACK;
terminal LBRACE;
terminal RBRACE;
terminal NIL;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal DIVIDE;
terminal COMMA;
terminal DOT;
terminal SEMICOLON;
terminal ASSIGN;
terminal EQ;
terminal LT;
terminal GT;
terminal ARRAY;
terminal CLASS;
terminal EXTENDS;
terminal RETURN;
terminal WHILE;
terminal IF;
terminal NEW;
terminal COMMENT;

terminal String STRING;
terminal Integer INT;
terminal String ID;

terminal ILLEGAL_CHARACTER;
terminal ILLEGAL_INTEGER;
terminal ILLEGAL_COMMENT;

/* NON TERMINALS */
non terminal AST_DecList decList;
non terminal AST_Dec dec;
non terminal AST_VarDec varDec;
non terminal AST_FuncDec funcDec;
non terminal AST_ClassDec classDec;
non terminal AST_ArrayDec arrayDec;
non terminal AST_ParamsList paramsList;
non terminal AST_ClassField cField;
non terminal AST_ClassFieldList cFieldList;
non terminal AST_Exp exp;
non terminal AST_Var var;
non terminal AST_ExpCall callExp;
non terminal AST_ExpBinOp binopExp;
non terminal AST_ExpPrimitive primitiveExp;
non terminal AST_ExpList expListComma;
non terminal AST_NewExp newExp;
non terminal AST_Stmt stmt;
non terminal AST_StmtList stmtList;

/* OPERATOR PRECEDENCE */
precedence nonassoc ASSIGN;
precedence left     EQ;
precedence left     LT;
precedence left     GT;
precedence left     PLUS;
precedence left     MINUS;
precedence left     TIMES;
precedence left     DIVIDE;
precedence nonassoc LBRACK;
precedence nonassoc LPAREN;
precedence left     DOT;


start with decList;


paramsList  ::=     ID:id1 ID:id2 COMMA paramsList:list {: RESULT = new AST_ParamsList(id1, id2, list); :} |
                    ID:id1 ID:id2                       {: RESULT = new AST_ParamsList(id1, id2, null); :} ;

cFieldList  ::=     cField:field cFieldList:list        {: RESULT = new AST_ClassFieldList(field, list); :} |
                    cField:field                        {: RESULT = new AST_ClassFieldList(field, null); :} ;

decList		::=		dec:d decList:l	{: RESULT = new AST_DecList(d, l);    :} |
                    dec:d			{: RESULT = new AST_DecList(d, null); :}
                    ;

dec			::=		varDec:d		{: RESULT = d; :} |
                    funcDec:d		{: RESULT = d; :} |
                    classDec:d		{: RESULT = d; :} |
                    arrayDec:d		{: RESULT = d; :}
                    ;
varDec		::=		ID:type ID:var SEMICOLON	                {: RESULT = new AST_VarDec(type, var, null); :} |
                    ID:type ID:var ASSIGN exp:e SEMICOLON       {: RESULT = new AST_VarDec(type, var, e); :} |
                    ID:type ID:var ASSIGN newExp:e SEMICOLON    {: RESULT = new AST_VarDec(type, var, e); :}
                    ;
funcDec		::=		ID:ret ID:name LPAREN paramsList:p RPAREN LBRACE stmtList:body RBRACE   {: RESULT = new AST_FuncDec(ret, name, p, body); :} |
                    ID:ret ID:name LPAREN RPAREN LBRACE stmtList:body RBRACE                {: RESULT = new AST_FuncDec(ret,name,null,body); :}
                    ;
classDec	::=		CLASS ID:name LBRACE cFieldList:l RBRACE	                {: RESULT = new AST_ClassDec(name, null, l); :} |
                    CLASS ID:name EXTENDS ID:base LBRACE cFieldList:l RBRACE	{: RESULT = new AST_ClassDec(name, base, l); :}
                    ;

arrayDec    ::=     ARRAY ID:name EQ ID:type LBRACK RBRACK                        {: RESULT = new AST_ArrayDec(name, type); :};

exp			::=		var:v		            {: RESULT = v; :} |
                    LPAREN exp:e RPAREN		{: RESULT = e; :} |
                    binopExp:e	            {: RESULT = e; :} |
                    callExp:e		        {: RESULT = e; :} |
                    primitiveExp:e          {: RESULT = e; :}
                    ;

var		::=		    ID:name						{: RESULT = new AST_VarSimple(name);       :} |
                    var:v DOT ID:fieldName		{: RESULT = new AST_VarClassField(v, fieldName); :} |
                    var:v LBRACK exp:e RBRACK	{: RESULT = new AST_VarArrayElement(v,e);     :}
                    ;

binopExp	::=		exp:e1 PLUS exp:e2		{: RESULT = new AST_ExpBinOp(e1, e2, '+'); :} |
                    exp:e1 MINUS exp:e2 	{: RESULT = new AST_ExpBinOp(e1, e2, '-'); :} |
                    exp:e1 TIMES exp:e2 	{: RESULT = new AST_ExpBinOp(e1, e2, '*'); :} |
                    exp:e1 DIVIDE exp:e2 	{: RESULT = new AST_ExpBinOp(e1, e2, '/'); :} |
                    exp:e1 LT exp:e2		{: RESULT = new AST_ExpBinOp(e1, e2, '<'); :} |
                    exp:e1 GT exp:e2		{: RESULT = new AST_ExpBinOp(e1, e2, '>'); :} |
                    exp:e1 EQ exp:e2		{: RESULT = new AST_ExpBinOp(e1, e2, '='); :}
                    ;

callExp		::=		ID:funcName LPAREN expListComma:args RPAREN             {: RESULT = new AST_ExpCall(funcName, null, args); :} |
                    var:v DOT ID:funcName LPAREN expListComma:args RPAREN   {: RESULT = new AST_ExpCall(funcName, v, args); :}
                    ;

primitiveExp    ::=     INT:i			        {: RESULT = new AST_ExpInt(i); :} |
                        MINUS INT:i			    {: RESULT = new AST_ExpInt(-i); :} |
                        STRING:s		        {: RESULT = new AST_ExpString(s); :} |
                        NIL		                {: RESULT = new AST_ExpNil(); :}
                        ;

expListComma	::=		exp:e COMMA expListComma:el	{: RESULT = new AST_ExpList(e,el);   :} |
                        exp:e						{: RESULT = new AST_ExpList(e,null); :}
                        ;

stmtList	::=		stmt:s stmtList:l	{: RESULT = new AST_StmtList(s,l);    :} |
                    stmt:s  			{: RESULT = new AST_StmtList(s,null); :}
                    ;
                    
stmt		::=		varDec:v                                                    {: RESULT = new AST_StmtVarDec(v);        :} |
                    var:v ASSIGN exp:e SEMICOLON						    	{: RESULT = new AST_StmtAssign(v,e);       :} |
                    RETURN exp:e SEMICOLON									    {: RESULT = new AST_StmtReturn(e);         :} |
                    IF    LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE	{: RESULT = new AST_StmtIf(cond,body);     :} |
                    WHILE LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE	{: RESULT = new AST_StmtWhile(cond,body);  :} |
                    callExp:callExp SEMICOLON									{: RESULT = new AST_StmtCall(callExp);     :}
                    ;

newExp      ::=     NEW ID:type                         {: RESULT = new AST_NewExp(type); :} |
                    NEW ID:type LBRACK exp:e RBRACK     {: RESULT = new AST_NewExp(type, e); :}
                    ;

cField      ::=     varDec:vDec                         {: RESULT = vDec; :} |
                    funcDec:fDec                        {: RESULT = fDec; :} ;
