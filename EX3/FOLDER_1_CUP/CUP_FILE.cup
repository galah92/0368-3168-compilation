import java.io.PrintWriter;
import java_cup.runtime.*;
import AST.*;

parser code 
{:
    public Lexer lexer;
    public PrintWriter writer;

    public Parser(Lexer lexer, PrintWriter writer)
    {
        this.lexer = lexer;
        this.writer = writer;
    }
    public void report_error(String message, Object info)
    {
        // writer.println("ParserError(" + lexer.getLine() + ", " + lexer.getCharPos() + ")");
        writer.println("ERROR(" + lexer.getLine() + ")");
        writer.close();
        System.exit(0);
    }
:}


/* CUSTOMIZE CUP PARSER */
scan with
{:
    return lexer.next_token();
:};


/* TERMINALS */
terminal LPAREN;
terminal RPAREN;
terminal LBRACK;
terminal RBRACK;
terminal LBRACE;
terminal RBRACE;
terminal NIL;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal DIVIDE;
terminal COMMA;
terminal DOT;
terminal SEMICOLON;
terminal ASSIGN;
terminal EQ;
terminal LT;
terminal GT;
terminal ARRAY;
terminal CLASS;
terminal EXTENDS;
terminal RETURN;
terminal WHILE;
terminal IF;
terminal NEW;

terminal String STRING;
terminal String ID;
terminal Integer INT;

/* NON TERMINALS */
non terminal DecList decList;
non terminal Dec dec;
non terminal VarDec varDec;
non terminal FuncDec funcDec;
non terminal ClassDec classDec;
non terminal ArrayDec arrayDec;
non terminal ParamsList paramsList;
non terminal ClassField cField;
non terminal ClassFieldList cFieldList;
non terminal Exp exp;
non terminal Var var;
non terminal ExpCall callExp;
non terminal ExpBinOp binopExp;
non terminal ExpPrimitive primitiveExp;
non terminal ExpList expList;
non terminal NewExp newExp;
non terminal Stmt stmt;
non terminal StmtList stmtList;

/* OPERATOR PRECEDENCE */
precedence nonassoc ASSIGN;
precedence left     EQ;
precedence left     LT;
precedence left     GT;
precedence left     PLUS;
precedence left     MINUS;
precedence left     TIMES;
precedence left     DIVIDE;
precedence nonassoc LBRACK;
precedence nonassoc LPAREN;
precedence left     DOT;


start with decList;


paramsList  ::=     ID:id1 ID:id2 COMMA paramsList:list {: RESULT = new ParamsList(id1, id2, list); RESULT.lineNumber = id1left; :} |
                    ID:id1 ID:id2                       {: RESULT = new ParamsList(id1, id2, null); RESULT.lineNumber = id1left; :} ;

cFieldList  ::=     cField:field cFieldList:list        {: RESULT = new ClassFieldList(field, list); RESULT.lineNumber = fieldleft; :} |
                    cField:field                        {: RESULT = new ClassFieldList(field, null); RESULT.lineNumber = fieldleft; :} ;

expList     ::=     exp:e COMMA expList:list            {: RESULT = new ExpList(e, list); RESULT.lineNumber = eleft; :} |
                    exp:e                               {: RESULT = new ExpList(e, null); RESULT.lineNumber = eleft; :} ;

decList		::=		dec:d decList:l	{: RESULT = new DecList(d, l); RESULT.lineNumber = dleft; :} |
                    dec:d			{: RESULT = new DecList(d, null); RESULT.lineNumber = dleft; :}
                    ;

dec			::=		varDec:d		{: RESULT = d; RESULT.lineNumber = dleft; :} |
                    funcDec:d		{: RESULT = d; RESULT.lineNumber = dleft; :} |
                    classDec:d		{: RESULT = d; RESULT.lineNumber = dleft; :} |
                    arrayDec:d		{: RESULT = d; RESULT.lineNumber = dleft; :}
                    ;
varDec		::=		ID:type ID:var SEMICOLON	                {: RESULT = new VarDec(type, var, null); RESULT.lineNumber = typeleft; :} |
                    ID:type ID:var ASSIGN exp:e SEMICOLON       {: RESULT = new VarDec(type, var, e); RESULT.lineNumber = typeleft; :} |
                    ID:type ID:var ASSIGN newExp:e SEMICOLON    {: RESULT = new VarDec(type, var, e); RESULT.lineNumber = typeleft; :}
                    ;
funcDec		::=		ID:ret ID:name LPAREN paramsList:p RPAREN LBRACE stmtList:body RBRACE   {: RESULT = new FuncDec(ret, name, p, body); RESULT.lineNumber = retleft; :} |
                    ID:ret ID:name LPAREN RPAREN LBRACE stmtList:body RBRACE                {: RESULT = new FuncDec(ret,name,null,body); RESULT.lineNumber = retleft; :}
                    ;
classDec	::=		CLASS ID:name LBRACE cFieldList:l RBRACE	                {: RESULT = new ClassDec(name, null, l); RESULT.lineNumber = lleft; :} |
                    CLASS ID:name EXTENDS ID:base LBRACE cFieldList:l RBRACE	{: RESULT = new ClassDec(name, base, l); RESULT.lineNumber = lleft; :}
                    ;

arrayDec    ::=     ARRAY ID:name EQ ID:Type LBRACK RBRACK                        {: RESULT = new ArrayDec(name, Type); RESULT.lineNumber = nameleft; :};

exp			::=		var:v		            {: RESULT = v; RESULT.lineNumber = vleft; :} |
                    LPAREN exp:e RPAREN		{: RESULT = e; RESULT.lineNumber = eleft; :} |
                    binopExp:e	            {: RESULT = e; RESULT.lineNumber = eleft; :} |
                    callExp:e		        {: RESULT = e; RESULT.lineNumber = eleft; :} |
                    primitiveExp:e          {: RESULT = e; RESULT.lineNumber = eleft; :}
                    ;

var		::=		    ID:name						{: RESULT = new VarSimple(name); RESULT.lineNumber = nameleft; :} |
                    var:v DOT ID:fieldName		{: RESULT = new VarClassField(v, fieldName); RESULT.lineNumber = vleft; :} |
                    var:v LBRACK exp:e RBRACK	{: RESULT = new VarArrayElement(v,e); RESULT.lineNumber = vleft; :}
                    ;

binopExp	::=		exp:e1 PLUS exp:e2		{: RESULT = new ExpBinOp(e1, e2, '+'); RESULT.lineNumber = e1left; :} |
                    exp:e1 MINUS exp:e2 	{: RESULT = new ExpBinOp(e1, e2, '-'); RESULT.lineNumber = e1left; :} |
                    exp:e1 TIMES exp:e2 	{: RESULT = new ExpBinOp(e1, e2, '*'); RESULT.lineNumber = e1left; :} |
                    exp:e1 DIVIDE exp:e2 	{: RESULT = new ExpBinOp(e1, e2, '/'); RESULT.lineNumber = e1left; :} |
                    exp:e1 LT exp:e2		{: RESULT = new ExpBinOp(e1, e2, '<'); RESULT.lineNumber = e1left; :} |
                    exp:e1 GT exp:e2		{: RESULT = new ExpBinOp(e1, e2, '>'); RESULT.lineNumber = e1left; :} |
                    exp:e1 EQ exp:e2		{: RESULT = new ExpBinOp(e1, e2, '='); RESULT.lineNumber = e1left; :}
                    ;

callExp		::=		ID:funcName LPAREN RPAREN                           {: RESULT = new ExpCall(funcName, null, null); RESULT.lineNumber = funcNameleft; :} |
                    ID:funcName LPAREN expList:args RPAREN              {: RESULT = new ExpCall(funcName, null, args); RESULT.lineNumber = funcNameleft; :} |
                    var:v DOT ID:funcName LPAREN RPAREN                 {: RESULT = new ExpCall(funcName, v, null); RESULT.lineNumber = funcNameleft; :} |
                    var:v DOT ID:funcName LPAREN expList:args RPAREN    {: RESULT = new ExpCall(funcName, v, args); RESULT.lineNumber = funcNameleft; :}
                    ;

primitiveExp    ::=     INT:i           {: RESULT = new ExpInt(i); RESULT.lineNumber = ileft; :} |
                        MINUS INT:i     {: RESULT = new ExpInt(-i); RESULT.lineNumber = ileft; :} |
                        STRING:s        {: RESULT = new ExpString(s); RESULT.lineNumber = sleft; :} |
                        NIL:n           {: RESULT = new ExpNil(); RESULT.lineNumber = nleft; :}
                        ;

stmtList	::=		stmt:s stmtList:l	{: RESULT = new StmtList(s,l); RESULT.lineNumber = sleft; :} |
                    stmt:s  			{: RESULT = new StmtList(s,null); RESULT.lineNumber = sleft; :}
                    ;
                    
stmt		::=		varDec:v                                                    {: RESULT = new StmtVarDec(v); RESULT.lineNumber = vleft; :} |
                    var:v ASSIGN exp:e SEMICOLON						    	{: RESULT = new StmtAssign(v,e); RESULT.lineNumber = vleft; :} |
                    var:v ASSIGN newExp:e SEMICOLON						    	{: RESULT = new StmtAssign(v,e); RESULT.lineNumber = vleft; :} |
                    RETURN:r SEMICOLON									        {: RESULT = new StmtReturn(null); RESULT.lineNumber = rleft; :} |
                    RETURN exp:e SEMICOLON									    {: RESULT = new StmtReturn(e); RESULT.lineNumber = eleft; :} |
                    IF    LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE	{: RESULT = new StmtIf(cond,body); RESULT.lineNumber = condleft; :} |
                    WHILE LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE	{: RESULT = new StmtWhile(cond,body); RESULT.lineNumber = condleft; :} |
                    callExp:callExp SEMICOLON									{: RESULT = new StmtCall(callExp); RESULT.lineNumber = callExpleft; :}
                    ;

newExp      ::=     NEW ID:type                         {: RESULT = new NewExp(type, null); RESULT.lineNumber = typeleft; :} |
                    NEW ID:type LBRACK exp:e RBRACK     {: RESULT = new NewExp(type, e); RESULT.lineNumber = typeleft; :}
                    ;

cField      ::=     varDec:d                         {: RESULT = d; RESULT.lineNumber = dleft; :} |
                    funcDec:d                        {: RESULT = d; RESULT.lineNumber = dleft; :} ;
